// -----------------------------------------------------------------

node Decl {
	declNode()
}

node Spec {
    specNode()
}

node Stmt {
    stmtNode()
}

node Expr {
	exprNode()
}

node GenDecl : Decl {
	TokPos pos
	Tok token
	Lparen pos
	Specs []Spec
	Rparen pos
}

node ImportSpec : Spec {
    Name Expr
    Path BasicLit
    EndPos pos
}

// -----------------------------------------------------------------

File = ("package" Name:Ident ";") Decls:(*(importDecl ";") *(toplevelDecl ";"))

toplevelDecl = valueDecl | typeDecl | FuncDecl

// -----------------------------------------------------------------

importDecl = "import" Specs:(ImportSpec | lp:"(" *(ImportSpec ";") rp:")") as GenDecl {
	TokPos: import.Pos
	Tok: import.Tok
	Lparen: lp.Pos
	Rparen: rp.Pos
}

ImportSpec = ?Name:(dotPkgName | Ident) Path:stringLit {
	EndPos: Path.End
}

dotPkgName = dot:"." as Ident {
	NamePos: dot.Pos
	Name: "."
}

stringLit = string as BasicLit {
	ValuePos: string.Pos
	Kind: string.Tok
	Value: string.Lit
}

// -----------------------------------------------------------------

valueDecl = valKw Specs:(ValueSpec | lp:"(" *(ValueSpec ";") rp:")") as GenDecl {
	TokPos: valKw.Pos
	Tok: valKw.Tok
	Lparen: lp.Pos
	Rparen: rp.Pos
}

valKw = "const" | "var"

ValueSpec = Names:identList ?Type ?Values:exprList

identList = Ident % ","

Ident = ident {
	NamePos: ident.Pos
	Name: ident.Lit
}

// -----------------------------------------------------------------

Type = typeNameEx | typeLit | "(" Type ")" as Expr

typeLit = ArrayType | StructType | pointerType | FuncType | InterfaceType | MapType | ChanType

typeNameEx = typeName ?(lp:"[" Indices:typeList rp:"]" as IndexListExpr {
	X: typeName
	Lbrack: lp.Pos
	Rbrack: rp.Pos
})

typeName = Ident | qualifiedIdent as Expr

typeList = Type % ","

qualifiedIdent = X:Ident "." Sel:Ident as SelectorExpr

// -----------------------------------------------------------------

ArrayType = lp:"[" Len:expr "]" Elt:Type {
	Lbrack: lp.Pos
}

// -----------------------------------------------------------------

AssignStmt = Lhs:exprList assignOp Rhs:exprList {
	TokPos: assignOp.Pos
	Tok: assignOp.Tok
}

exprList = expr % ","

assignOp = ":=" | "=" | "+=" | "-=" | "*=" | "/=" | "%="

// -----------------------------------------------------------------

expr = unaryExpr | BinaryExpr

BinaryExpr = X:expr binOp Y:expr { // TODO: precedence
	OpPos: binOp.Pos
	Op: binOp.Tok
}

binOp = "||" | "&&" | relOp | addOp | mulOp

relOp = "==" | "!=" | "<" | "<=" | ">" | ">="

addOp = "+" | "-" | "|" | "^"

mulOp = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^"

unaryExpr = primaryExpr | (unaryOp X:unaryExpr as UnaryExpr {
	OpPos: unaryOp.Pos
	Op: unaryOp.Tok
})

unaryOp = "+" | "-" | "!" | "^" | "*" | "&" | "<-"

primaryExpr = operand | CallExpr | SelectorExpr | IndexExpr | SliceExpr | TypeAssertExpr

operand = TODO

CallExpr = Fun:primaryExpr lp:"(" Args:exprList ?el:"..." ?"," rp:")" {
	Lparen: lp.Pos
	Rparen: rp.Pos
	Ellipsis: el != nil
}

SelectorExpr = X:primaryExpr "." Sel:Ident

IndexExpr = X:primaryExpr lp:"[" Index:expr ?"," rp:"]" {
	Lbrack: lp.Pos
	Rbrack: rp.Pos
}

SliceExpr = X:primaryExpr lp:"[" ?Low:expr ":" ?High:expr ?(":" Max:expr) rp:"]" {
	Lbrack: lp.Pos
	Rbrack: rp.Pos
	Slice3: Max != nil
}

TypeAssertExpr = X:primaryExpr "." lp:"(" Type rp:")" {
	Lparen: lp.Pos
	Rparen: rp.Pos
}

// -----------------------------------------------------------------
