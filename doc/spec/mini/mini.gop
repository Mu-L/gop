/*
 * Copyright (c) 2025 The GoPlus Authors (goplus.org). All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mini

import (
	"github.com/goplus/gop/token"
	"github.com/goplus/gop/tpl"
)

const (
	domianTextQuote  = '`'
	domianTextExpect = "expect domainTag`...`"
)

var _off = tpl.showConflict(false)

var cl = tpl`

SourceFile = ?PackageClause *(ImportDecl ";") *(TopLevelDecl ";") ?MainStmts

PackageClause = "package" IDENT ";"

ImportDecl = "import" (ImportSpec | "(" *(ImportSpec ";") ")")

ImportSpec = ?(IDENT | ".") STRING

TopLevelDecl = Declaration | FuncDecl

Declaration = ConstDecl | VarDecl | TypeDecl

ConstDecl = "const" (ConstSpec | "(" *(ConstSpec ";") ")")

ConstSpec = IdentifierList ?Type ?("=" ExpressionList)

IdentifierList = IDENT % ","

ExpressionList = Expression % ","

VarDecl = "var" (VarSpec | "(" *(VarSpec ";") ")")

VarSpec = IdentifierList ("=" ExpressionList | Type ?("=" ExpressionList))

TypeDecl = "type" (TypeSpec | "(" *(TypeSpec ";") ")")

TypeSpec = IDENT ?"=" Type

FuncDecl = "func" IDENT Signature ?Block

Signature = Parameters ?Result

Parameters = "(" ?(ParameterList ?",") ")"

ParameterList = IdentifierList ?(Type *("," IdentifierList Type) | *("," Type))

Result = Parameters | NoParenType

MainStmts = StatementList

// -----------------------------------------------------------------

Block = "{" StatementList "}"

StatementList = *(Statement ";")

Statement =
	Declaration | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | IfStmt | SwitchStmt | ForStmt | DeferStmt | Block |
	LabeledStmt | CommandStmt | SimpleStmt

ReturnStmt = "return" ?ExpressionList

BreakStmt = "break" ?IDENT

ContinueStmt = "continue" ?IDENT

GotoStmt = "goto" IDENT

FallthroughStmt = "fallthrough"

IfStmt = "if" ?(SimpleStmt ";") Expression Block ?("else" (IfStmt | Block))

SwitchStmt = "switch" ?(SimpleStmt ";") SwitchGuard "{" *CaseClause "}"

SwitchGuard = ?(IDENT ":=") PrimaryExpr "." "(" "type" ")" | ?Expression

CaseClause = ("case" ExpressionList | "default") ":" StatementList

ForStmt = "for" ?Expression Block

DeferStmt = "defer" Expression

LabeledStmt = IDENT ":" Statement

SimpleStmt = ShortVarDecl | IncDecStmt | Assignment | ExpressionStmt | EmptyStmt

ShortVarDecl = IdentifierList ":=" ExpressionList

IncDecStmt = Expression ("++" | "--")

Assignment = ExpressionList (
	"=" | "+=" | "-=" | "|=" | "^=" |
	"*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "&^=") ExpressionList

ExpressionStmt = Expression

CommandStmt = IDENT ?("." IDENT) ExpressionList

EmptyStmt = ""

// -----------------------------------------------------------------

NoParenType = TypeLit | TypeName

Type = TypeLit | TypeName | "(" Type ")"

TypeName = IDENT ?("." IDENT)

TypeLit = PointerType | ArrayType | MapType | FuncType | StructType | InterfaceType

PointerType = "*" Type

ArrayType = "[" ?Expression "]" Type

EllipsisArrayType = "[" ?("..." | Expression) "]" Type

MapType = "map" "[" Type "]" Type

FuncType = "func" Signature

StructType = "struct" "{" *(FieldDecl ";") "}"

FieldDecl = ("*" TypeName | FieldsOrNonPtrEmbeddedField) ?Tag

FieldsOrNonPtrEmbeddedField = IDENT ("." IDENT | +("," IDENT) Type | ?Type)

Tag = STRING

InterfaceType = "interface" "{" *(InterfaceElem ";") "}"

InterfaceElem = MethodElem

MethodElem = IDENT Signature

// -----------------------------------------------------------------

Expression = cmpExpr % "&&" % "||"

cmpExpr = mathExpr % ("==" | "!=" | "<" | "<=" | ">" | ">=")

mathExpr = UnaryExpr % ("*" | "/" | "%" | "<<" | ">>" | "&" | "&^") % ("+" | "-" | "|" | "^")

UnaryExpr = PrimaryExpr | ("-" | "!" | "^" | "*" | "&" | "+") UnaryExpr

PrimaryExpr = Operand *(
	CallOrConversion | SelectorOrTypeAssertion | IndexOrSlice | ErrWrap | LiteralValue)

Operand =
	INT ?UNIT | FLOAT ?UNIT | STRING | CHAR | CSTRING | PYSTRING | RAT | IMAG |
	CompositeLit | FunctionLit | "(" Expression ")" | DomainTextLit | IDENT

DomainTextLit = IDENT STRING => {
	tag := self[0].(*tpl.Token)
	text := self[1].(*tpl.Token)
	if tag.End() != text.Pos || text.Lit[0] != domianTextQuote {
		panic &tpl.Error{Pos: tag.Pos, Msg: domianTextExpect}
	}
	return self
}

CompositeLit = LiteralTypeLit LiteralValue

LiteralTypeLit = EllipsisArrayType | MapType | StructType

LiteralValue = "{" ElementList ?"," "}"

ElementList = KeyedElement % ","

KeyedElement = ?(Key ":") Element

Key = LiteralValue | Expression

Element = LiteralValue | Expression

FunctionLit = "func" Signature Block

CallOrConversion = "(" ?(Expression % ",") ?"..." ?"," ")"

SelectorOrTypeAssertion = "." (IDENT | "(" Type ")")

IndexOrSlice = "[" (":" ?Expression | Expression (":" ?Expression | ?",")) "]"

ErrWrap = "!" | "?" ?(":" UnaryExpr)
`!

// -----------------------------------------------------------------

func ParseFile(fset *token.FileSet, filename string, src any) (any, error) {
	return cl.Parse(filename, src, &tpl.Config{
		Fset: fset,
	})
}

// -----------------------------------------------------------------
